import scala.reflect.ClassTag

trait MyQueue[A]:
    //Objekte eines beliebig aber festen Typs A sind gespeichert

    //Vor: Keine
    //Erg: Keins
    //Effekt: x ist nun das aktuellste Element in der Queue
    def enqueue(x: A) : Unit

    //Vor: Der Stack ist nicht leer
    //Erg: Das älteste Element der Queue ist geliefert
    //Eff: Das älteste Element aus der Queue entfernt
    def dequeue(): A

    //Vor: Keine
    //Erg: Es ist true geliefert, genau dann wenn die Queue leer ist
    //Eff: Keiner 
    def isEmpty : Boolean

    //Vor: Keine
    //Erg: Die Anzahl der Elemente in der Queue ist geliefert
    //Eff: Keiner
    def size : Int


class LinkedNodeQueue[A] extends MyQueue[A]:
    private class Node(val item:A, var next: Node)

    private var _size : Int = 0
    private var frontNode : Node = null
    private var backNode :  Node = null

    def isEmpty: Boolean = frontNode == null
    def size: Int = _size
    def dequeue(): A = 
        if isEmpty then
            throw new Exception("Emtpy Queue") 
        else
            val n : Node = frontNode
            frontNode = frontNode.next
            _size -=1
            n.item

    def enqueue(x: A): Unit =
        val n = new Node(x, null)
        if !isEmpty then
            backNode.next = n
        else
            backNode = n
            frontNode = n
        _size += 1

    override def toString(): String = 
        var s : String  = "front<"
        var n : Node = frontNode
        while n != null do
            s += " |" + n.item
            n=n.next
        s+="<back"
        s

class ArrayQUeue[A:ClassTag](private val capacity:Int) extends MyQueue[A]:

    private val n : Int = if capacity < 1 then 1 else capacity
    private val array:Array[A] = new Array[A](n)
    private var front = 0
    private var back = 0

    def isEmpty: Boolean = front == back

    def size: Int = (back-front+n)%n

    def enqueue(x: A): Unit =
        if size >= n-1 then throw new Exception("Queue full")
        array(back) = x
        back = (back+1) % n

    def dequeue(): A =
        if isEmpty then throw new Exception("Empty Queue")
        val result: A = Array(front)
        array(front) = null.asInstanceOf[A]
        front = (front+1) % n
        result

// Immutable Queue

trait ImmutableQueue[A]:
    // Gespeichert werden beliebige Daten von einem festen Typ A

    def size: Int
    def isEmpty: Int

    // Vor: keine
    // Erg: eine neue ImmutableQueue mit elem als neustem Element 
    //      ist geliefert
    def enqueue(elem: A): ImmutableQueue[A]

    // Vor: Die Queue ist nicht leer
    // Erg: ein Tupel aus dem ältesten Element und der Queue ohne 
    //      das älteste Element ist geliefert
    def dequeue(): (A, ImmutableQueue[A])

class FunctionalListQueue[A](private val input: List[A],
                             private val output: List[A])
                             extends FunctionalQueue[A]:
    private def reverse: FunctionalListQueue[A] =
        if input.isEmpty then FunctionalListQueue[A](input.reverse, Nil) else this

    def size: Int = input.length + output.length
    def isEmpty: Boolean = size == 0 // input.isEmpty && output.isEmpty (isEmpty-Fkt. der Scala-Listen)

    def enqueue(elem: A):FunctionalListQueue[A] = 
        new FunctionalListQueue[A](elem::input, output)

    def dequeue:(A, FunctionalListQueue[A]) =
        if isEmpty then throw new Exception("Empty Queue")
        val q = this.reverse
        (q.output.head, new FunctionalListQueue[A](q.input, q.ouput.tail))

trait PrioQueue[K:Ordering]:
    // In einer Prioritätswarteschlange werden Elemente aus einem total 
    // geordnetem Universum gespeichert

    // Vor: keine
    // Eff: Das Element key ist zur Prioritätswarteschlange hinzugefügt
    // Erg: keins
    def insert(key: K): Unit

    // Vor: Die Prioritätswarteschlange ist nicht leer
    // Eff: Das kleinste Element ist aus der Prioritätswarteschlange entfernt
    // Erg: Das kleinste Element ist geliefert
    def extractMin():K

    // Vor: keine
    // Eff: keiner
    // Erg: true ist geliefert, genau dann, wenn die Prioritätswarteschlange leer ist
    def isEmpty: Boolean

def prioQueueSort[K:Ordering](array:Array[K]): Unit = 
    val n = array.length
    val pq: PrioQueue[K] = new PQImpL[K]()
    for a <- array do pq.insert(a)
    for i <- 0 to n-1 do
        array(i) = pq.extractMin()
